\chapter{Related Work}
\label{chap:related}
This area of research is becoming more and more popular in recent years with more and more publications in top conferences such as NIPS and POPL, attracting researchers from universities such as MIT and Stanford and industry research institutions such as Microsoft Research. However, to our best knowledge, this area has not even been studied in China. We have evaluated the existing probabilistic programming systems including BUGS, Church, FACTORIE, Infer.NET, Dimple, etc. More specifically, BUGS is a language for specifying finite graphical models and accompanying software for performing Bayesian inference Using Gibbs Sampling. Church is a universal probabilistic programming language, extending Scheme with probabilistic semantics, and is well suited for describing infinite-dimensional stochastic processes and other recursively-defined generative processes. Factorial is a Scala library for creating relational factor graphs, estimating parameters and performing inference. Infer.NET is a software library developed by Microsoft for expressing graphical models and implementing Bayesian inference using a variety of algorithms within the .NET platform. Dimple is a software tool that performs inference and learning on probabilistic graphical models via belief propagation algorithms or sampling based algorithms. In summary, all these probabilistic programming languages are extended from a domain language and each of them inherits the same syntax and the data types of the domain language.

In this chapter, we will introduce the state of the art probabilistic programming languages and systems as well as the current problems existed for probabilistic programming.

\section{BUGS}

\section{Infer.NET}

\section{Church}
Church extends (the purely functional subset of) Scheme with elementary random primitives, such as flip (a bernoulli), multino- mial, and gaussian. In addition, Church includes language con- structs that simplify modeling. For instance, mem, a higher-order procedure that memoizes its input function, is useful for describing persistent random properties and lazy model construction. (Inter- estingly, memoization has a semantic effect in probabilistic lan- guages.) If we view the semantics of the underlying deterministic language as a map from programs to executions of the program, the semantics of the probabilistic language will be a map from programs to distributions over executions. When the program halts with probability one, this induces a proper distribution over return values. Indeed, any computable distribution can be represented as the distribution induced by a Church program in this way(see ~\cite{goodman}, ~\cite{church}, ~\cite{lightweight}).
\section{FACTORIE}

\section{Lightweight Implementation of Probabilistic Programming Language}
~\cite{lightweight}, ~\cite{nonstandard}

\section{Problem}
\label{sec:prob}

Although currently there are many probabilistic programming languages and systems, as stated above, the problem is that this is not easy for those cross-platform developments where they have to get accustomed to the different kinds of probabilistic programming languages or libraries. Henceforth, what we proposed is the Portable Probabilistic Programming Framework that can be embedded in every programming language people commonly used.

We designed the syntax for the portable probabilistic programming language which targets Bayesian networks and conditional query. The design of the language is based on BUGS and is more specific and efficient for describing the probabilistic models. The description of the models using the portable probabilistic programming language is separated from the code of the host language as well of the conditional query, which can enhance the reusability of the probabilistic models. The parser is implemented and the inference engine is generated automatically based on the conditional query. The inference algorithm is based on the MCMC sampling, such as Gibbs Sampling or Metropolis-Hastings Algorithm, which is efficient and lightweight to implement. Additionally, the APIs for other languages is attached leveraging some existing development tool such as SWIG (Simplified Wrapper and Interface Generator). 

Our main contribution lies in the design of the portable probabilistic programming language to make it portable, the implementation of the probabilistic library and the lightweight implementation of the inference engine. 